package com.ubs.cumulus.bbg.psr.download;

import com.ubs.cumulus.bbg.client.BbgAuthService;
import com.ubs.cumulus.bbg.client.BlobServiceClient;
import com.ubs.cumulus.bbg.kafka.EdfKafkaEventService;
import com.ubs.cumulus.bbg.model.DownloadInfo;
import com.ubs.cumulus.bbg.model.RequestStatus;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.DefaultDataBufferFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.client.*;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.nio.ByteBuffer;
import java.util.List;

import static org.assertj.core.api.Assertions.*;
import static org.mockito.Mockito.*;

class BbgFileDownloadServiceTest {

    @Mock
    private BbgAuthService authService;

    @Mock
    private BlobServiceClient blobServiceClient;

    @Mock
    private EdfKafkaEventService kafkaEventService;

    @Mock
    private WebClient webClient;

    @InjectMocks
    private BbgFileDownloadService service;

    @BeforeEach
    void setup() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testDownloadToBlob_whenBlobDoesNotExist_shouldDownloadAndWrite() throws Exception {
        // Mock blob logic
        var blobContainerClient = mock(com.azure.storage.blob.BlobContainerClient.class);
        var blobClient = mock(com.azure.storage.blob.specialized.BlockBlobClient.class);
        var blobOutputStream = mock(java.io.OutputStream.class);

        when(blobServiceClient.getBlobContainerClient("bloomberg")).thenReturn(blobContainerClient);
        when(blobContainerClient.getBlobClient(anyString()).getBlockBlobClient()).thenReturn(blobClient);
        when(blobClient.exists()).thenReturn(false);
        when(blobClient.getBlobOutputStream()).thenReturn(blobOutputStream);

        // Stub download call
        byte[] dummyBytes = "test-data".getBytes();
        DataBuffer buffer = new DefaultDataBufferFactory().wrap(dummyBytes);
        doReturn(Flux.just(buffer)).when(service).download(anyString(), anyString());

        var result = service.downloadToBlob("url", "requestId", "file", "dl").block();

        assertThat(result.getStatus()).isEqualTo(RequestStatus.DOWNLOAD_SUCCESS);
        verify(kafkaEventService).createEDFEvent("requestId", result.getPath(), "acquisition.pipeline.succeeded");
    }

    @Test
    void testDownloadToBlob_whenBlobExists_shouldSkipDownload() {
        var blobContainerClient = mock(com.azure.storage.blob.BlobContainerClient.class);
        var blobClient = mock(com.azure.storage.blob.specialized.BlockBlobClient.class);

        when(blobServiceClient.getBlobContainerClient("bloomberg")).thenReturn(blobContainerClient);
        when(blobContainerClient.getBlobClient(anyString()).getBlockBlobClient()).thenReturn(blobClient);
        when(blobClient.exists()).thenReturn(true);

        var result = service.downloadToBlob("url", "requestId", "file", "dl").block();

        assertThat(result.getStatus()).isEqualTo(RequestStatus.DOWNLOAD_SKIPPED);
        assertThat(result.getReason()).contains("duplicate");
    }

    @Test
    void testDownloadToBlob_whenException_shouldSetFailedStatus() {
        var blobContainerClient = mock(com.azure.storage.blob.BlobContainerClient.class);
        var blobClient = mock(com.azure.storage.blob.specialized.BlockBlobClient.class);

        when(blobServiceClient.getBlobContainerClient("bloomberg")).thenReturn(blobContainerClient);
        when(blobContainerClient.getBlobClient(anyString()).getBlockBlobClient()).thenReturn(blobClient);
        when(blobClient.exists()).thenReturn(false);
        when(blobClient.getBlobOutputStream()).thenThrow(new RuntimeException("write failed"));

        var result = service.downloadToBlob("url", "reqId", "file", "dl").block();

        assertThat(result.getStatus()).isEqualTo(RequestStatus.DOWNLOAD_FAILED);
        assertThat(result.getReason()).contains("write failed");
        verify(kafkaEventService).createEDFEvent("reqId", result.getPath(), "acquisition.pipeline.failed");
    }

    @Test
    void testDownload_shouldReturnDataBufferFlux() {
        var uriSpec = mock(WebClient.RequestHeadersUriSpec.class);
        var headersSpec = mock(WebClient.RequestHeadersSpec.class);
        var responseSpec = mock(WebClient.ResponseSpec.class);

        when(webClient.get()).thenReturn(uriSpec);
        when(uriSpec.uri(any())).thenReturn(headersSpec);
        when(headersSpec.header(eq(HttpHeaders.AUTHORIZATION), anyString())).thenReturn(headersSpec);
        when(headersSpec.header(eq("api-version"), anyString())).thenReturn(headersSpec);
        when(headersSpec.accept(MediaType.APPLICATION_OCTET_STREAM)).thenReturn(headersSpec);
        when(headersSpec.retrieve()).thenReturn(responseSpec);
        when(responseSpec.onStatus(any(), any())).thenReturn(responseSpec);

        DataBuffer buffer = new DefaultDataBufferFactory().wrap("data".getBytes());
        when(responseSpec.bodyToFlux(DataBuffer.class)).thenReturn(Flux.just(buffer));

        when(authService.getToken("dl")).thenReturn("mock-token");

        Flux<DataBuffer> result = service.download("http://test-url", "dl");

        List<DataBuffer> buffers = result.collectList().block();
        assertThat(buffers).isNotEmpty();
    }
}
