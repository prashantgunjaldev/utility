import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.*;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.mock.env.MockEnvironment;
import org.springframework.test.util.ReflectionTestUtils;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.BodyInserters;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClient.RequestBodyUriSpec;
import org.springframework.web.reactive.function.client.WebClient.RequestHeadersSpec;
import org.springframework.web.reactive.function.client.WebClient.RequestBodySpec;
import org.springframework.web.reactive.function.client.WebClient.ResponseSpec;
import reactor.core.publisher.Mono;

import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.atomic.AtomicReference;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

class BbgAuthServiceTest {

    @Mock
    private WebClient webClient;

    @Mock
    private WebClient.RequestBodyUriSpec requestBodyUriSpec;

    @Mock
    private WebClient.RequestBodySpec requestBodySpec;

    @Mock
    private WebClient.RequestHeadersSpec<?> requestHeadersSpec;

    @Mock
    private WebClient.ResponseSpec responseSpec;

    @InjectMocks
    private BbgAuthService authService;

    @BeforeEach
    void setUp() throws Exception {
        MockitoAnnotations.openMocks(this);

        // Set all @Value config fields via reflection
        ReflectionTestUtils.setField(authService, "authTokenUrl", "https://test/token");
        ReflectionTestUtils.setField(authService, "requestTimeout", 5);
        ReflectionTestUtils.setField(authService, "maxRetryAttempts", 1);
        // Provide a minimal but valid credentials JSON string
        String credsJson = "{\"dl1\":\"user:pass\"}";
        ReflectionTestUtils.setField(authService, "credentialsJson", credsJson);

        // Set internal webClient field manually (constructor-injected final)
        Field f = BbgAuthService.class.getDeclaredField("webClient");
        f.setAccessible(true);
        f.set(authService, webClient);

        // Re-initialize internals such as credentials and cache
        ReflectionTestUtils.invokeMethod(authService, "mapDLs");
    }

    @Test
    void testMapDLs_initializesCredentialsAndCache() throws Exception {
        Field c = BbgAuthService.class.getDeclaredField("credentials");
        c.setAccessible(true);
        Map<String, String> creds = (Map<String, String>) c.get(authService);
        assertNotNull(creds);
        assertEquals("user:pass", creds.get("dl1"));

        Field m = BbgAuthService.class.getDeclaredField("tokenCacheMap");
        m.setAccessible(true);
        Map<String, AtomicReference<?>> map = (Map<String, AtomicReference<?>>) m.get(authService);
        assertNotNull(map.get("dl1"));
    }

    @Test
    void testGetDLList_returnsKeySet() {
        List<String> list = authService.getDLList();
        assertEquals(Collections.singletonList("dl1"), list);
    }

    @Test
    void testCreateAuthHeaderString_encodesProperly() {
        String result = ReflectionTestUtils.invokeMethod(authService, "createAuthHeaderString", "dl1");
        String decoded = new String(Base64.getDecoder().decode(result.substring(6)), StandardCharsets.UTF_8);
        assertEquals("user:pass", decoded);
        assertTrue(result.startsWith("Basic "));
    }

    @Test
    void testGetToken_cacheHit() {
        // Arrange: simulate AtomicReference containing valid cached token
        Field mapField = ReflectionTestUtils.findField(BbgAuthService.class, "tokenCacheMap");
        assert mapField != null;
        mapField.setAccessible(true);

        Map<String, AtomicReference<BbgCachedAuthToken>> cacheMap = (Map<String, AtomicReference<BbgCachedAuthToken>>) mapField.get(authService);

        BbgCachedAuthToken token = new BbgCachedAuthToken("access", java.time.Instant.now().plusSeconds(300));
        cacheMap.get("dl1").set(token);

        // Act
        String val = authService.getToken("dl1");

        // Assert
        assertEquals("access", val);
    }
    
    @Test
    void testGetToken_cacheMiss_callsRefresh() throws Exception {
        // Arrange: force cache to be empty
        Field mapField = ReflectionTestUtils.findField(BbgAuthService.class, "tokenCacheMap");
        mapField.setAccessible(true);
        Map<String, AtomicReference<BbgCachedAuthToken>> cacheMap = (Map<String, AtomicReference<BbgCachedAuthToken>>) mapField.get(authService);
        cacheMap.get("dl1").set(null);

        // Spy to verify if refresh is indeed called
        BbgAuthService spy = Mockito.spy(authService);
        doReturn("newtoken").when(spy).refresh("dl1");

        // Act
        String result = spy.getToken("dl1");

        // Assert: fallback to refresh
        assertEquals("newtoken", result);
        verify(spy, times(1)).refresh("dl1");
    }

    @Test
    void testRefresh_successfulSetsTokenAndReturnsAccessToken() {
        // Mock downstream getNewAccessToken
        BbgAuthService spy = Mockito.spy(authService);
        BbgTokenResponse resp = new BbgTokenResponse();
        resp.setAccess_token("tok123");
        resp.setExpires_in(299);

        doReturn(Mono.just(resp)).when(spy).getNewAccessToken(anyString());

        String result = spy.refresh("dl1");
        assertEquals("tok123", result);
    }

    @Test
    void testRefresh_returnsNullOnTokenFailure() {
        BbgAuthService spy = Mockito.spy(authService);
        doReturn(Mono.empty()).when(spy).getNewAccessToken(anyString());
        String result = spy.refresh("dl1");
        assertNull(result);
    }

    @Test
    void testGetNewAccessToken_goodResponse() {
        // Arrange webClient mock chain
        when(webClient.post()).thenReturn(requestBodyUriSpec);
        when(requestBodyUriSpec.uri(anyString())).thenReturn(requestBodySpec);
        when(requestBodySpec.header(anyString(), anyString())).thenReturn(requestBodySpec);
        when(requestBodySpec.body(any(BodyInserters.FromFormData.class))).thenReturn(requestHeadersSpec);
        when(requestHeadersSpec.retrieve()).thenReturn(responseSpec);
        BbgTokenResponse resp = new BbgTokenResponse();
        resp.setAccess_token("tok123");
        resp.setExpires_in(60);
        when(responseSpec.bodyToMono(eq(BbgTokenResponse.class))).thenReturn(Mono.just(resp));
        // Act & Assert
        Mono<BbgTokenResponse> mono = ReflectionTestUtils.invokeMethod(authService, "getNewAccessToken", "dl1");
        assertNotNull(mono);
        BbgTokenResponse out = mono.block();
        assertEquals("tok123", out.getAccess_token());
    }

    @Test
    void testMapDLs_handlesJsonException() throws Exception {
        // Force credentialsJson to be invalid JSON
        ReflectionTestUtils.setField(authService, "credentialsJson", "{");

        // Expose method via reflection
        Exception e = assertThrows(RuntimeException.class, () -> {
            ReflectionTestUtils.invokeMethod(authService, "mapDLs");
        });
        assertTrue(e.getMessage().contains("Unexpected end-of-input"));
    }
}
