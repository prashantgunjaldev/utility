import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.*;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.*;
import java.util.concurrent.Semaphore;
import java.util.concurrent.ConcurrentLinkedQueue;

import static org.mockito.Mockito.*;
import static org.junit.jupiter.api.Assertions.*;

@ExtendWith(MockitoExtension.class)
class DownloadQueueServiceTest {

    @Mock
    private BbgFileDownloadService downloaderService;
    @Mock
    private DownloadTaskRepository repository;
    @Mock
    private BbgFileRepository fileRepository;
    @Mock
    private PsrRequestLogRepository requestLogRepository;

    @InjectMocks
    private DownloadQueueService downloadQueueService;

    @Mock
    private DownloadTaskEntity taskMock;
    @Mock
    private DownloadInfo downloadInfoMock;
    @Mock
    private PsrRequestLogEntity psrRequestLogEntityMock;
    @Mock
    private BbgFileEntity bbgFileEntityMock;

    @BeforeEach
    void setUp() {
        // Inject required mock values for final fields if any
        // For actual code, set via reflection or constructor if needed
    }

    @Test
    void testSubmitDownload() {
        // Arrange
        doNothing().when(repository).save(any());
        doNothing().when(taskMock).setStatus(any());
        doNothing().when(taskMock).setUpdatedAt(any());

        // Act
        downloadQueueService.submitDownload(taskMock);

        // Assert: It should add to queue and processQueue is normally invoked (may need partial/mock for queue)
        // Usually, behavior verification for public result and/or internal interaction
        verify(repository, never()).save(taskMock); // As it's only saved in logStateInDb for success case
    }

    @Test
    void testProcessQueue_withTask() {
        // Arrange
        DownloadTaskEntity realTask = mock(DownloadTaskEntity.class);

        // Mocking the tryAcquire
        Semaphore downloadSlots = new Semaphore(1, true);
        // You may have to use reflection if semaphore is final/private

        Queue<DownloadTaskEntity> queue = new ConcurrentLinkedQueue<>();
        queue.offer(realTask);

        // Simulate downloadService, .downloadToBlob returns a publisher, so can stub as needed

        when(realTask.getRequestId()).thenReturn("req1");
        when(realTask.getFileName()).thenReturn("file");
        when(realTask.getVendorAccount()).thenReturn("vendor");
        when(downloaderService.downloadToBlob(anyString(), anyString(), anyString()))
            .thenAnswer(invocation -> {
                // Simulate publisher behaviour, thenNext & doFinally logic can be simulated
                return downloadInfoMock;
            });

        // Because queue and semaphore are object fields, you'll need to set them via reflection if they're private
        // For demonstration, assume they're accessible here:

        // downloadQueueService.queue = queue;
        // downloadQueueService.downloadSlots = downloadSlots;

        // Act
        // (May need further work if processQueue is private/package-private)

        // downloadQueueService.processQueue();

        // Assert
        // verify logic, or use AssertJ/assertions for expected changes
    }

    @Test
    void testLogStateInDb_downloadSuccess() {
        // Arrange
        when(downloadInfoMock.getStatus()).thenReturn(RequestStatus.DOWNLOAD_SUCCESS.name());
        when(taskMock.getStatus()).thenReturn(RequestStatus.DOWNLOAD_SUCCESS.name());
        when(taskMock.getFileName()).thenReturn("fileName");
        when(downloadInfoMock.getPath()).thenReturn("filePath");
        when(taskMock.getVendorAccount()).thenReturn("vendorAcct");
        when(taskMock.getRequestId()).thenReturn("requestId");

        when(requestLogRepository.getPsrRequestLogEntityByBbgRequestId(anyString()))
            .thenReturn(psrRequestLogEntityMock);
        when(psrRequestLogEntityMock.getAcqRequestId()).thenReturn("acqReqId");

        // Do not throw for save methods
        doNothing().when(fileRepository).save(any());
        doNothing().when(requestLogRepository).save(any());

        // Act
        // Reflection or package-private access may be needed
        // downloadQueueService.logStateInDb(downloadInfoMock, taskMock);

        // Assert
        verify(fileRepository).save(any());
        verify(requestLogRepository).save(any());
    }

    @Test
    void testLogStateInDb_notDownloadSuccess() {
        // Arrange
        when(downloadInfoMock.getStatus()).thenReturn(RequestStatus.FAILED.name());

        // Act
        // downloadQueueService.logStateInDb(downloadInfoMock, taskMock);

        // Assert
        // Should not save to fileRepository
        verify(fileRepository, never()).save(any());
        verify(requestLogRepository).save(any());
    }

    @Test
    void testTaskPoller_handlesExceptionGracefully() {
        // Arrange
        when(repository.claimTasks(anyInt(), anyString())).thenThrow(new RuntimeException("DB error"));

        // Act & Assert
        // Should not throw any exception, just log
        assertDoesNotThrow(() -> downloadQueueService.taskPoller());
    }

    // Add further tests to simulate all branches, exceptions, empty queue, zero semaphore permits, etc.

}
