import reactor.netty.http.client.HttpClient;
import org.springframework.web.reactive.function.client.WebClient;
import java.time.Duration;
import io.netty.handler.ssl.SslContextBuilder;
import javax.net.ssl.SSLException;
import reactor.netty.transport.logging.AdvancedByteBufFormat;
import reactor.netty.transport.TransportConfig;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;

// Build a custom HttpClient that trusts all certificates
HttpClient httpClient = HttpClient.create()
    .followRedirect(true) // automatically follow redirects
    .secure(sslSpec -> sslSpec.sslContext(SslContextBuilder.forClient()
        .trustManager(InsecureTrustManagerFactory.INSTANCE))) // trust all SSL certs
    .responseTimeout(Duration.ofSeconds(60));

// Build WebClient with advanced settings
WebClient cleanClient = WebClient.builder()
    .clientConnector(new reactor.netty.http.client.HttpClientConnector(httpClient))
    .defaultHeader(HttpHeaders.USER_AGENT, "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/112 Safari/537.36")
    .build();

// Now do the GET call
Mono<ResponseEntity<byte[]>> data = cleanClient.get()
    .uri(sasUrl)
    .retrieve()
    .toEntity(byte[].class);

// Then block or return depending on your controller
