// src/main/java/com/bloomberg/psr/BloombergPsrApplication.java
package com.bloomberg.psr;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.r2dbc.repository.config.EnableR2dcRepositories;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling // Enable scheduling for token refresh or polling
@EnableR2dcRepositories // Enable R2DBC repositories for reactive database access
public class BloombergPsrApplication {

    public static void main(String[] args) {
        SpringApplication.run(BloombergPsrApplication.class, args);
    }
}
```java
// src/main/java/com/bloomberg/psr/config/AppConfig.java
package com.bloomberg.psr.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.client.WebClient;

import java.time.Duration;

@Configuration
public class AppConfig {

    @Value("${bloomberg.psr.api.baseUrl}")
    private String bloombergPsrApiBaseUrl;

    @Value("${bloomberg.oauth.tokenUrl}")
    private String bloombergOauthTokenUrl;

    @Value("${bloomberg.sse.baseUrl}")
    private String bloombergSseBaseUrl;

    @Value("${azure.blob.storage.baseUrl}")
    private String azureBlobStorageBaseUrl;

    @Value("${oasys.notification.api.baseUrl}")
    private String oasysNotificationApiBaseUrl;

    /**
     * Configures and provides a WebClient for Bloomberg PSR API interactions.
     * This WebClient is pre-configured with the base URL and default headers.
     *
     * @return WebClient instance for Bloomberg PSR API.
     */
    @Bean("bloombergPsrWebClient")
    public WebClient bloombergPsrWebClient() {
        return WebClient.builder()
                .baseUrl(bloombergPsrApiBaseUrl)
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

    /**
     * Configures and provides a WebClient for Bloomberg OAuth token requests.
     *
     * @return WebClient instance for Bloomberg OAuth.
     */
    @Bean("bloombergOAuthWebClient")
    public WebClient bloombergOAuthWebClient() {
        return WebClient.builder()
                .baseUrl(bloombergOauthTokenUrl)
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_FORM_URLENCODED_VALUE)
                .build();
    }

    /**
     * Configures and provides a WebClient for Bloomberg SSE API interactions.
     *
     * @return WebClient instance for Bloomberg SSE.
     */
    @Bean("bloombergSseWebClient")
    public WebClient bloombergSseWebClient() {
        return WebClient.builder()
                .baseUrl(bloombergSseBaseUrl)
                // SSE typically uses text/event-stream, no need to set default content-type for requests
                .build();
    }

    /**
     * Configures and provides a WebClient for Azure Blob Storage downloads.
     *
     * @return WebClient instance for Azure Blob Storage.
     */
    @Bean("azureBlobWebClient")
    public WebClient azureBlobWebClient() {
        return WebClient.builder()
                .baseUrl(azureBlobStorageBaseUrl)
                .build();
    }

    /**
     * Configures and provides a WebClient for OASYS notification API.
     *
     * @return WebClient instance for OASYS notification API.
     */
    @Bean("oasysNotificationWebClient")
    public WebClient oasysNotificationWebClient() {
        return WebClient.builder()
                .baseUrl(oasysNotificationApiBaseUrl)
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .build();
    }

    /**
     * Provides an ObjectMapper for JSON serialization/deserialization.
     * Important for parsing complex JSON from SSE events.
     *
     * @return ObjectMapper instance.
     */
    @Bean
    public ObjectMapper objectMapper() {
        return new ObjectMapper();
    }
}
```java
// src/main/java/com/bloomberg/psr/audit/AuditLog.java
package com.bloomberg.psr.audit;

import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Column;
import org.springframework.data.relational.core.mapping.Table;
import java.time.LocalDateTime;

/**
 * Represents an audit log entry stored in the database.
 * Used to track the lifecycle of a Bloomberg PSR request.
 */
@Table("audit_log")
public class AuditLog {
    @Id
    private Long id;

    @Column("request_id")
    private String requestId; // The unique ID of the Bloomberg PSR request

    @Column("event_type")
    private String eventType; // e.g., "API_RECEIVED", "REQUEST_SUBMITTED", "SSE_EVENT_RECEIVED", "DOWNLOAD_STARTED", "DOWNLOAD_COMPLETED", "NOTIFICATION_SENT"

    private String status; // e.g., "SUCCESS", "FAILURE", "IN_PROGRESS", "ACCEPTED", "WARNING"

    private String message; // Detailed message about the event

    @Column("related_key")
    private String relatedKey; // Could be fileKey for downloads, or Bloomberg response ID

    private LocalDateTime timestamp;

    // Constructors
    public AuditLog() {
        this.timestamp = LocalDateTime.now();
    }

    public AuditLog(String requestId, String eventType, String status, String message, String relatedKey) {
        this(); // Call default constructor to set timestamp
        this.requestId = requestId;
        this.eventType = eventType;
        this.status = status;
        this.message = message;
        this.relatedKey = relatedKey;
    }

    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getRequestId() { return requestId; }
    public void setRequestId(String requestId) { this.requestId = requestId; }
    public String getEventType() { return eventType; }
    public void setEventType(String eventType) { this.eventType = eventType; }
    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    public String getRelatedKey() { return relatedKey; }
    public void setRelatedKey(String relatedKey) { this.relatedKey = relatedKey; }
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    @Override
    public String toString() {
        return "AuditLog{" +
               "id=" + id +
               ", requestId='" + requestId + '\'' +
               ", eventType='" + eventType + '\'' +
               ", status='" + status + '\'' +
               ", message='" + message + '\'' +
               ", relatedKey='" + relatedKey + '\'' +
               ", timestamp=" + timestamp +
               '}';
    }
}
```java
// src/main/java/com/bloomberg/psr/audit/AuditLogRepository.java
package com.bloomberg.psr.audit;

import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import org.springframework.stereotype.Repository;

/**
 * Reactive repository for AuditLog entities, interacting with the database via R2DBC.
 */
@Repository
public interface AuditLogRepository extends ReactiveCrudRepository<AuditLog, Long> {
    // Spring Data R2DBC automatically provides basic CRUD operations.
    // Custom reactive query methods can be added here if needed,
    // e.g., Mono<AuditLog> findByRequestId(String requestId);
}
```java
// src/main/java/com/bloomberg/psr/audit/AuditService.java
package com.bloomberg.psr.audit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

/**
 * Service for managing and logging audit events into the PostgreSQL database.
 */
@Service
public class AuditService {
    private static final Logger log = LoggerFactory.getLogger(AuditService.class);
    private final AuditLogRepository auditLogRepository;

    public AuditService(AuditLogRepository auditLogRepository) {
        this.auditLogRepository = auditLogRepository;
    }

    /**
     * Logs an audit event to the database.
     * This method subscribes to the save operation to ensure it's executed,
     * but returns Mono<Void> to prevent blocking the calling reactive chain.
     *
     * @param requestId  The unique identifier for the main request flow.
     * @param eventType  The type of event (e.g., "REQUEST_INITIATED", "DOWNLOAD_COMPLETED").
     * @param status     The status of the event (e.g., "SUCCESS", "FAILURE", "IN_PROGRESS").
     * @param message    A descriptive message for the event.
     * @param relatedKey A key related to the event (e.g., fileKey, Bloomberg response ID).
     * @return Mono<Void> indicating the completion of the logging operation.
     */
    public Mono<Void> logEvent(String requestId, String eventType, String status, String message, String relatedKey) {
        AuditLog auditLog = new AuditLog(requestId, eventType, status, message, relatedKey);
        return auditLogRepository.save(auditLog)
                .doOnSuccess(savedLog -> log.debug("Audit event logged: {}", savedLog))
                .doOnError(e -> log.error("Failed to log audit event [RequestId: {}, EventType: {}]: {}", requestId, eventType, e.getMessage(), e))
                .then(); // Convert to Mono<Void> to signify completion without returning data
    }
}
```java
// src/main/java/com/bloomberg/psr/oauth/OAuthToken.java
package com.bloomberg.psr.oauth;

import java.time.Instant;

/**
 * Represents an OAuth token with its access token value and expiration time.
 */
public class OAuthToken {
    private final String accessToken;
    private final Instant expirationTime;

    public OAuthToken(String accessToken, long expiresInSeconds) {
        this.accessToken = accessToken;
        // Set expiration time slightly before the actual expiry for safety
        this.expirationTime = Instant.now().plusSeconds(expiresInSeconds - 60);
    }

    public String getAccessToken() {
        return accessToken;
    }

    /**
     * Checks if the token is expired or about to expire.
     *
     * @return true if the token is expired or close to expiration, false otherwise.
     */
    public boolean isExpired() {
        return Instant.now().isAfter(expirationTime);
    }
}
```java
// src/main/java/com/bloomberg/psr/oauth/OAuthService.java
package com.bloomberg.psr.oauth;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;
import reactor.util.retry.Retry;

import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.atomic.AtomicReference;

/**
 * Service for managing OAuth tokens. Generates and caches the token in memory
 * for approximately 1 hour, refreshing it as needed.
 */
@Service
public class OAuthService {

    private static final Logger log = LoggerFactory.getLogger(OAuthService.class);
    private final WebClient bloombergOAuthWebClient;

    @Value("${bloomberg.oauth.clientId}")
    private String clientId;

    @Value("${bloomberg.oauth.clientSecret}")
    private String clientSecret;

    @Value("${bloomberg.oauth.grantType}")
    private String grantType;

    // In-memory cache for the OAuth token
    private final AtomicReference<OAuthToken> cachedToken = new AtomicReference<>();

    public OAuthService(@Qualifier("bloombergOAuthWebClient") WebClient bloombergOAuthWebClient) {
        this.bloombergOAuthWebClient = bloombergOAuthWebClient;
    }

    /**
     * Retrieves a valid OAuth token. If the token is not present or expired, it requests a new one.
     *
     * @return Mono emitting the OAuth token string.
     */
    public Mono<String> getAccessToken() {
        OAuthToken currentToken = cachedToken.get();
        if (currentToken == null || currentToken.isExpired()) {
            log.info("OAuth token is missing or expired. Requesting a new token.");
            return requestNewAccessToken()
                    .doOnNext(cachedToken::set) // Cache the new token upon successful retrieval
                    .map(OAuthToken::getAccessToken)
                    .doOnError(e -> log.error("Failed to retrieve new OAuth token: {}", e.getMessage()));
        } else {
            log.debug("Using cached OAuth token.");
            return Mono.just(currentToken.getAccessToken());
        }
    }

    /**
     * Makes an HTTP POST call to the Bloomberg OAuth endpoint to request a new access token.
     * Includes retry logic for transient errors.
     *
     * @return Mono emitting the newly obtained OAuthToken object.
     */
    private Mono<OAuthToken> requestNewAccessToken() {
        MultiValueMap<String, String> formData = new LinkedMultiValueMap<>();
        formData.add("client_id", clientId);
        formData.add("client_secret", clientSecret);
        formData.add("grant_type", grantType);

        return bloombergOAuthWebClient.post()
                .bodyValue(formData)
                .retrieve()
                .onStatus(HttpStatus::isError, clientResponse ->
                        clientResponse.bodyToMono(String.class)
                                .flatMap(errorBody -> Mono.error(new RuntimeException(
                                        String.format("OAuth token request failed with status %s: %s", clientResponse.statusCode(), errorBody)
                                )))
                )
                .bodyToMono(TokenResponse.class)
                .retryWhen(Retry.backoff(3, Duration.ofSeconds(2))
                        .filter(throwable -> throwable instanceof RuntimeException && throwable.getMessage().contains("status 5")) // Retry on server errors
                        .doBeforeRetry(retrySignal -> log.warn("Retrying OAuth token request. Attempt: {}", retrySignal.totalRetries() + 1))
                        .onRetryExhausted((retryBackoffSpec, retrySignal) ->
                                log.error("Max retries for OAuth token request exhausted.")
                        )
                )
                .map(response -> new OAuthToken(response.getAccessToken(), response.getExpiresIn()))
                .doOnSuccess(token -> log.info("Successfully obtained new OAuth token. Expires in {} seconds.", token.getExpirationTime().getEpochSecond() - Instant.now().getEpochSecond()))
                .doOnError(e -> log.error("Error during OAuth token request: {}", e.getMessage()));
    }

    /**
     * Inner class to represent the structure of the OAuth token response.
     */
    private static class TokenResponse {
        private String access_token;
        private long expires_in; // In seconds

        public String getAccessToken() {
            return access_token;
        }

        public void setAccessToken(String access_token) {
            this.access_token = access_token;
        }

        public long getExpiresIn() {
            return expires_in;
        }

        public void setExpiresIn(long expires_in) {
            this.expires_in = expires_in;
        }
    }
}
```java
// src/main/java/com/bloomberg/psr/request/PsrRequestPayload.java
package com.bloomberg.psr.request;

import java.util.List;
import java.util.Map;

/**
 * Represents the payload for a Bloomberg Per Security Request.
 * This is a simplified example; actual payload structure will depend on Bloomberg's API documentation
 * for DataRequest, HistoryRequest, CorporateActionsRequest.
 */
public class PsrRequestPayload {
    private String requestId; // A unique identifier for the request
    private String requestType; // e.g., "DataRequest", "HistoryRequest", "ActionsRequest"
    private List<String> securities; // List of Bloomberg tickers or IDs
    private List<String> fields; // List of Bloomberg data fields

    // For History Requests
    private String startDate;
    private String endDate;
    private String period; // e.g., "DAILY", "WEEKLY"

    // For Corporate Actions, some fields might be ignored or not needed as per docs

    // Constructor
    public PsrRequestPayload(String requestId, String requestType, List<String> securities, List<String> fields) {
        this.requestId = requestId;
        this.requestType = requestType;
        this.securities = securities;
        this.fields = fields;
    }

    // Constructor for History Requests
    public PsrRequestPayload(String requestId, String requestType, List<String> securities, List<String> fields, String startDate, String endDate, String period) {
        this.requestId = requestId;
        this.requestType = requestType;
        this.securities = securities;
        this.fields = fields;
        this.startDate = startDate;
        this.endDate = endDate;
        this.period = period;
    }

    // Getters and Setters
    public String getRequestId() {
        return requestId;
    }

    public void setRequestId(String requestId) {
        this.requestId = requestId;
    }

    public String getRequestType() {
        return requestType;
    }

    public void setRequestType(String requestType) {
        this.requestType = requestType;
    }

    public List<String> getSecurities() {
        return securities;
    }

    public void setSecurities(List<String> securities) {
        this.securities = securities;
    }

    public List<String> getFields() {
        return fields;
    }

    public void setFields(List<String> fields) {
        this.fields = fields;
    }

    public String getStartDate() {
        return startDate;
    }

    public void setStartDate(String startDate) {
        this.startDate = startDate;
    }

    public String getEndDate() {
        return endDate;
    }

    public void setEndDate(String endDate) {
        this.endDate = endDate;
    }

    public String getPeriod() {
        return period;
    }

    public void setPeriod(String period) {
        this.period = period;
    }

    // You might want to add a fluent builder pattern for complex payloads
    public static class Builder {
        private String requestId;
        private String requestType;
        private List<String> securities;
        private List<String> fields;
        private String startDate;
        private String endDate;
        private String period;

        public Builder requestId(String requestId) {
            this.requestId = requestId;
            return this;
        }

        public Builder requestType(String requestType) {
            this.requestType = requestType;
            return this;
        }

        public Builder securities(List<String> securities) {
            this.securities = securities;
            return this;
        }

        public Builder fields(List<String> fields) {
            this.fields = fields;
            return this;
        }

        public Builder startDate(String startDate) {
            this.startDate = startDate;
            return this;
        }

        public Builder endDate(String endDate) {
            this.endDate = endDate;
            return this;
        }

        public Builder period(String period) {
            this.period = period;
            return this;
        }

        public PsrRequestPayload build() {
            PsrRequestPayload payload = new PsrRequestPayload(requestId, requestType, securities, fields);
            payload.setStartDate(startDate);
            payload.setEndDate(endDate);
            payload.setPeriod(period);
            return payload;
        }
    }
}
```java
// src/main/java/com/bloomberg/psr/request/PsrRequestService.java
package com.bloomberg.psr.request;

import com.bloomberg.psr.audit.AuditService;
import com.bloomberg.psr.oauth.OAuthService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;
import reactor.util.retry.Retry;

import java.time.Duration;

/**
 * Service for making HTTP POST requests to the Bloomberg PSR API.
 */
@Service
public class PsrRequestService {

    private static final Logger log = LoggerFactory.getLogger(PsrRequestService.class);
    private final WebClient bloombergPsrWebClient;
    private final OAuthService oAuthService;
    private final AuditService auditService; // Inject AuditService

    @Value("${bloomberg.psr.api.catalog}")
    private String catalogId;

    public PsrRequestService(
            @Qualifier("bloombergPsrWebClient") WebClient bloombergPsrWebClient,
            OAuthService oAuthService,
            AuditService auditService) { // Inject AuditService
        this.bloombergPsrWebClient = bloombergPsrWebClient;
        this.oAuthService = oAuthService;
        this.auditService = auditService; // Initialize AuditService
    }

    /**
     * Makes an asynchronous HTTP POST request to the Bloomberg PSR API.
     * Retrieves an OAuth token and includes it in the Authorization header.
     *
     * @param payload The request payload containing details for the Bloomberg PSR.
     * @return Mono emitting the response body as a String (e.g., a request ID or confirmation).
     */
    public Mono<String> submitPsrRequest(PsrRequestPayload payload) {
        String requestId = payload.getRequestId(); // Get requestId from payload

        return oAuthService.getAccessToken()
                .flatMap(accessToken -> {
                    log.info("Submitting PSR request with ID: {}", requestId);
                    // Log request initiation
                    auditService.logEvent(requestId, "REQUEST_SUBMITTED", "IN_PROGRESS", "Bloomberg PSR request being submitted to external API.", requestId).subscribe();

                    return bloombergPsrWebClient.post()
                            .uri("/catalogs/{catalog}/requests/", catalogId)
                            .header(HttpHeaders.AUTHORIZATION, "Bearer " + accessToken)
                            .bodyValue(payload)
                            .retrieve()
                            .onStatus(HttpStatus::isError, clientResponse ->
                                    clientResponse.bodyToMono(String.class)
                                            .flatMap(errorBody -> Mono.error(new RuntimeException(
                                                    String.format("PSR request failed with status %s: %s", clientResponse.statusCode(), errorBody)
                                            )))
                            )
                            .bodyToMono(String.class) // Assuming the response is a simple string for now (e.g., request ID)
                            .retryWhen(Retry.backoff(3, Duration.ofSeconds(2))
                                    .filter(throwable -> throwable instanceof RuntimeException && throwable.getMessage().contains("status 5")) // Retry on server errors
                                    .doBeforeRetry(retrySignal -> log.warn("Retrying PSR request for ID {}. Attempt: {}", requestId, retrySignal.totalRetries() + 1))
                                    .onRetryExhausted((retryBackoffSpec, retrySignal) ->
                                            log.error("Max retries for PSR request ID {} exhausted.", requestId)
                                    )
                            )
                            .doOnSuccess(response -> {
                                log.info("Successfully submitted PSR request {}. Response: {}", requestId, response);
                                // Log successful submission
                                auditService.logEvent(requestId, "REQUEST_SENT", "SUCCESS", "PSR request sent to Bloomberg successfully.", response).subscribe();
                            })
                            .doOnError(e -> {
                                log.error("Error submitting PSR request {}: {}", requestId, e.getMessage());
                                // Log submission failure
                                auditService.logEvent(requestId, "REQUEST_SEND_FAILED", "FAILURE", "Failed to send PSR request: " + e.getMessage(), requestId).subscribe();
                            });
                });
    }

    /**
     * Placeholder for response object from Bloomberg PSR API.
     * Actual implementation might need to parse a more complex JSON response.
     */
    private static class PsrResponse {
        // Define fields based on actual Bloomberg PSR API response for POST /requests
    }
}
```java
// src/main/java/com/bloomberg/psr/polling/SseNotification.java
package com.bloomberg.psr.polling;

/**
 * Represents a Server-Sent Event (SSE) notification from Bloomberg.
 * This class is designed to capture the structure of a DistributionPublishedActivity event.
 * Note: The actual JSON structure from Bloomberg's SSE might be more complex and nested.
 * This is a simplified representation based on the provided image.
 */
public class SseNotification {

    // Common SSE event fields (often prefixed with "event:" and "data:")
    // Jackson will map these from the raw SSE string if present, otherwise they'll be null.
    // The "data" field will hold the actual JSON payload for specific events like DistributionPublishedActivity.
    private String id; // Event ID from "id:" line
    private String event; // Event type from "event:" line, e.g., "message", "DistributionPublishedActivity"
    private String data; // Raw JSON payload from "data:" line

    // Fields specific to DistributionPublishedActivity, parsed from 'data' JSON string
    // These are directly mapped from the JSON payload within the 'data' field.
    private String context; // "@context"
    private String type; // "@type", should be "DistributionPublishedActivity"
    private String endedAtTime;
    private Generated generated;

    public static class Generated {
        private String type; // e.g., "Distribution"
        private String key; // The key to download the file
        private String name;
        private String identifier;
        private String publisher;
        private String catalog; // Catalog ID

        // Getters and Setters for Generated
        public String getType() {
            return type;
        }

        public void setType(String type) {
            this.type = type;
        }

        public String getKey() {
            return key;
        }

        public void setKey(String key) {
            this.key = key;
        }

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public String getIdentifier() {
            return identifier;
        }

        public void setIdentifier(String identifier) {
            this.identifier = identifier;
        }

        public String getPublisher() {
            return publisher;
        }

        public void setPublisher(String publisher) {
            this.publisher = publisher;
        }

        public String getCatalog() {
            return catalog;
        }

        public void setCatalog(String catalog) {
            this.catalog = catalog;
        }

        @Override
        public String toString() {
            return "Generated{" +
                   "type='" + type + '\'' +
                   ", key='" + key + '\'' +
                   ", name='" + name + '\'' +
                   ", identifier='" + identifier + '\'' +
                   ", publisher='" + publisher + '\'' +
                   ", catalog='" + catalog + '\'' +
                   '}';
        }
    }


    // Getters and Setters for SseNotification
    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getEvent() {
        return event;
    }

    public void setEvent(String event) {
        this.event = event;
    }

    public String getData() {
        return data;
    }

    public void setData(String data) {
        this.data = data;
    }

    public String getContext() {
        return context;
    }

    public void setContext(String context) {
        this.context = context;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getEndedAtTime() {
        return endedAtTime;
    }

    public void setEndedAtTime(String endedAtTime) {
        this.endedAtTime = endedAtTime;
    }

    public Generated getGenerated() {
        return generated;
    }

    public void setGenerated(Generated generated) {
        this.generated = generated;
    }

    @Override
    public String toString() {
        return "SseNotification{" +
               "id='" + id + '\'' +
               ", event='" + event + '\'' +
               ", data='" + data + '\'' +
               ", context='" + context + '\'' +
               ", type='" + type + '\'' +
               ", endedAtTime='" + endedAtTime + '\'' +
               ", generated=" + generated +
               '}';
    }
}
```java
// src/main/java/com/bloomberg/psr/polling/PsrPollingService.java
package com.bloomberg.psr.polling;

import com.bloomberg.psr.audit.AuditService;
import com.bloomberg.psr.download.FileDownloadService;
import com.bloomberg.psr.oauth.OAuthService;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.retry.Retry;

import javax.annotation.PostConstruct;
import java.time.Duration;

/**
 * Service for polling the Bloomberg SSE (Server-Sent Events) API.
 * It listens for notifications about data availability and triggers the download process.
 */
@Service
public class PsrPollingService {

    private static final Logger log = LoggerFactory.getLogger(PsrPollingService.class);
    private final WebClient bloombergSseWebClient;
    private final OAuthService oAuthService;
    private final FileDownloadService fileDownloadService;
    private final AuditService auditService; // Inject AuditService
    private final ObjectMapper objectMapper; // For parsing SSE data payload

    @Value("${bloomberg.sse.api.path:/notifications/sse}")
    private String sseApiPath;

    @Value("${bloomberg.psr.api.catalog}")
    private String catalogId;

    public PsrPollingService(
            @Qualifier("bloombergSseWebClient") WebClient bloombergSseWebClient,
            OAuthService oAuthService,
            FileDownloadService fileDownloadService,
            AuditService auditService, // Inject AuditService
            ObjectMapper objectMapper) {
        this.bloombergSseWebClient = bloombergSseWebClient;
        this.oAuthService = oAuthService;
        this.fileDownloadService = fileDownloadService;
        this.auditService = auditService; // Initialize AuditService
        this.objectMapper = objectMapper;
    }

    /**
     * Initializes the SSE polling process after the bean has been constructed.
     * This method continuously attempts to connect to the SSE endpoint.
     */
    @PostConstruct
    public void startSsePolling() {
        log.info("Starting Bloomberg SSE polling...");
        // This ensures the SSE connection is always attempted and re-established
        // if it breaks, with a delay.
        pollSseEvents()
                // Use repeatWhenEmpty for continuous reconnection if the stream completes or errors out
                .repeatWhenEmpty(Long.MAX_VALUE, retrySpec -> {
                    log.warn("SSE stream ended or failed, attempting to reconnect in {} seconds.", retrySpec.currentRetryDuration().getSeconds());
                    auditService.logEvent("GLOBAL_SSE", "SSE_CONNECTION_LOST", "WARNING", "SSE stream ended or failed, attempting reconnection.", null).subscribe();
                    return retrySpec.delayElements(Duration.ofSeconds(10)); // Initial delay before first retry
                })
                .subscribe(
                        notification -> {
                            log.info("Received SSE notification: Type={}, Key={}", notification.getType(), notification.getGenerated() != null ? notification.getGenerated().getKey() : "N/A");

                            // In a real scenario, you'd need a mechanism to link this SSE notification back
                            // to the original PSR request ID. This might involve storing a mapping
                            // when the PSR request is submitted, and looking it up here using the `key`
                            // or other metadata provided by Bloomberg in the SSE event.
                            String requestId = "UNKNOWN_REQUEST_ID_FROM_SSE"; // Placeholder
                            String fileKey = (notification.getGenerated() != null) ? notification.getGenerated().getKey() : null;

                            if ("DistributionPublishedActivity".equals(notification.getType()) && fileKey != null) {
                                log.info("DistributionPublishedActivity received for key: {}. Triggering download.", fileKey);
                                auditService.logEvent(requestId, "SSE_EVENT_RECEIVED", "SUCCESS", "Data availability event received.", fileKey).subscribe();

                                // Trigger file download once a data availability event is received
                                fileDownloadService.downloadFile(catalogId, fileKey, requestId) // Pass requestId for audit
                                        .subscribe(
                                                filePath -> log.info("File downloaded successfully to: {}", filePath),
                                                error -> log.error("Error downloading file for key {}: {}", fileKey, error.getMessage())
                                        );
                            } else if (notification.getEvent() != null && notification.getEvent().equals("message") && (notification.getData() == null || notification.getData().trim().isEmpty())) {
                                log.debug("Received SSE heartbeat notification.");
                                // Heartbeat notifications are typically ignored for auditing purposes
                            } else {
                                log.warn("Received unhandled SSE notification: {}", notification);
                                auditService.logEvent(requestId, "SSE_EVENT_UNHANDLED", "WARNING", "Unhandled SSE notification: " + notification.toString(), fileKey).subscribe();
                            }
                        },
                        error -> {
                            log.error("SSE connection terminated with unrecoverable error: {}", error.getMessage(), error);
                            auditService.logEvent("GLOBAL_SSE", "SSE_CONNECTION_TERMINATED", "FAILURE", "SSE connection terminated with unrecoverable error: " + error.getMessage(), null).subscribe();
                        },
                        () -> {
                            log.warn("SSE connection completed unexpectedly. The `repeatWhenEmpty` operator should handle reconnection.");
                            auditService.logEvent("GLOBAL_SSE", "SSE_CONNECTION_CLOSED", "WARNING", "SSE connection completed unexpectedly.", null).subscribe();
                        }
                );
    }

    /**
     * Connects to the SSE endpoint and processes incoming events.
     * It fetches an OAuth token, sets the Authorization header, and retries on errors.
     *
     * @return Flux of SseNotification objects.
     */
    private Flux<SseNotification> pollSseEvents() {
        return oAuthService.getAccessToken()
                .flatMapMany(accessToken -> {
                    log.info("Attempting to connect to Bloomberg SSE at {} with Authorization header.", sseApiPath);
                    return bloombergSseWebClient.get()
                            .uri(sseApiPath)
                            .header(HttpHeaders.AUTHORIZATION, "Bearer " + accessToken)
                            .accept(MediaType.TEXT_EVENT_STREAM) // Important for SSE
                            .retrieve()
                            .bodyToFlux(String.class) // Receive each SSE event as a raw string
                            .filter(eventString -> eventString != null && !eventString.trim().isEmpty())
                            .flatMap(this::parseSseEventString) // Parse the string into SseNotification object
                            .retryWhen(Retry.backoff(Long.MAX_VALUE, Duration.ofSeconds(5)) // Infinite retries with backoff
                                    .filter(throwable -> {
                                        boolean shouldRetry = true; // Retry on all exceptions for SSE stream resilience
                                        log.warn("SSE connection error, retrying in 5 seconds. Error: {}", throwable.getMessage());
                                        return shouldRetry;
                                    })
                                    .doBeforeRetry(retrySignal -> log.warn("Retrying SSE connection. Attempt: {}", retrySignal.totalRetries() + 1))
                            )
                            .doOnComplete(() -> log.warn("SSE stream completed unexpectedly within flatMapMany. This should be handled by repeatWhenEmpty."))
                            .doOnError(e -> log.error("Error in SSE stream within flatMapMany: {}", e.getMessage(), e));
                })
                .doOnError(e -> {
                    log.error("Failed to obtain OAuth token for SSE polling: {}", e.getMessage());
                    auditService.logEvent("GLOBAL_SSE", "AUTH_FAILURE", "FAILURE", "Failed to obtain OAuth token for SSE polling: " + e.getMessage(), null).subscribe();
                });
    }

    /**
     * Parses a raw SSE event string into an SseNotification object.
     * It handles standard SSE fields like "id:", "event:", "data:".
     * For "DistributionPublishedActivity" events, it further parses the 'data' field (JSON payload).
     *
     * @param eventString The raw string received from the SSE stream.
     * @return Mono of SseNotification, or empty if parsing fails or it's a heartbeat.
     */
    private Mono<SseNotification> parseSseEventString(String eventString) {
        SseNotification notification = new SseNotification();
        String[] lines = eventString.split("\\r?\\n"); // Split by newline (CRLF or LF)

        String currentData = "";
        for (String line : lines) {
            if (line.startsWith("id:")) {
                notification.setId(line.substring(3).trim());
            } else if (line.startsWith("event:")) {
                notification.setEvent(line.substring(6).trim());
            } else if (line.startsWith("data:")) {
                // Accumulate data lines if an event can span multiple data: lines
                currentData += line.substring(5).trim();
            }
            // An empty line usually signifies the end of an event, trigger parsing
            else if (line.trim().isEmpty() && !currentData.isEmpty()) {
                notification.setData(currentData);
                // Attempt to parse the accumulated JSON data field
                if (notification.getData() != null && !notification.getData().isEmpty()) {
                    try {
                        // Deserialize the data payload into a temporary SseNotification object
                        SseNotification parsedData = objectMapper.readValue(notification.getData(), SseNotification.class);
                        notification.setContext(parsedData.getContext());
                        notification.setType(parsedData.getType());
                        notification.setEndedAtTime(parsedData.getEndedAtTime());
                        notification.setGenerated(parsedData.getGenerated());
                    } catch (JsonProcessingException e) {
                        log.error("Failed to parse SSE data JSON: {} - {}", notification.getData(), e.getMessage());
                        // If parsing fails, we still return the raw notification with data, but log the error
                    }
                }
                currentData = ""; // Reset for next event
            }
        }

        // Handle cases where the event string might just be a single data line without a final empty line
        if (!currentData.isEmpty() && notification.getData() == null) {
            notification.setData(currentData);
            if (notification.getData() != null && !notification.getData().isEmpty()) {
                try {
                    SseNotification parsedData = objectMapper.readValue(notification.getData(), SseNotification.class);
                    notification.setContext(parsedData.getContext());
                    notification.setType(parsedData.getType());
                    notification.setEndedAtTime(parsedData.getEndedAtTime());
                    notification.setGenerated(parsedData.getGenerated());
                } catch (JsonProcessingException e) {
                    log.error("Failed to parse SSE data JSON (single line): {} - {}", notification.getData(), e.getMessage());
                }
            }
        }

        // Filter out heartbeat events which typically have no meaningful data
        // Based on the image, heartbeats are "empty notifications that do not have any content".
        // They often just send 'data: ' or 'event: message' with no data.
        if ("message".equals(notification.getEvent()) && (notification.getData() == null || notification.getData().trim().isEmpty())) {
            log.debug("Skipping SSE heartbeat event.");
            return Mono.empty();
        }
        return Mono.just(notification);
    }
}
```java
// src/main/java/com/bloomberg/psr/download/FileDownloadService.java
package com.bloomberg.psr.download;

import com.bloomberg.psr.audit.AuditService;
import com.bloomberg.psr.notification.OasysNotificationService;
import com.bloomberg.psr.oauth.OAuthService;
import com.azure.storage.blob.BlobClient;
import com.azure.storage.blob.BlobContainerClient;
import com.azure.storage.blob.BlobServiceClient;
import com.azure.storage.blob.BlobServiceClientBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.core.io.buffer.DataBufferUtils; // Import DataBufferUtils
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.util.retry.Retry;

import javax.annotation.PostConstruct;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.Duration;

/**
 * Service for downloading files from Azure Blob Storage once notified by Bloomberg SSE.
 */
@Service
public class FileDownloadService {

    private static final Logger log = LoggerFactory.getLogger(FileDownloadService.class);
    private final WebClient azureBlobWebClient;
    private final OAuthService oAuthService;
    private final OasysNotificationService oasysNotificationService; // To send notification after download
    private final AuditService auditService; // Inject AuditService

    @Value("${azure.blob.storage.connectionString}")
    private String azureBlobStorageConnectionString;

    @Value("${azure.blob.storage.containerName}")
    private String azureBlobStorageContainerName;

    @Value("${app.download.location:./downloads}") // Default download location
    private String downloadLocation;

    private BlobContainerClient blobContainerClient;

    public FileDownloadService(
            @Qualifier("azureBlobWebClient") WebClient azureBlobWebClient,
            OAuthService oAuthService,
            OasysNotificationService oasysNotificationService,
            AuditService auditService) { // Inject AuditService
        this.azureBlobWebClient = azureBlobWebClient;
        this.oAuthService = oAuthService;
        this.oasysNotificationService = oasysNotificationService;
        this.auditService = auditService; // Initialize AuditService
        initializeAzureBlobClient();
    }

    /**
     * Initializes the Azure Blob Storage client and ensures the download directory exists.
     */
    @PostConstruct // Ensures this runs after constructor and value injection
    private void initializeAzureBlobClient() {
        try {
            BlobServiceClient blobServiceClient = new BlobServiceClientBuilder()
                    .connectionString(azureBlobStorageConnectionString)
                    .buildClient();
            this.blobContainerClient = blobServiceClient.getBlobContainerClient(azureBlobStorageContainerName);
            if (!blobContainerClient.exists()) {
                log.warn("Azure Blob Storage container '{}' does not exist. Attempting to create it.", azureBlobStorageContainerName);
                blobContainerClient.create();
            }
            // Ensure the download directory exists
            Path downloadDirPath = Paths.get(downloadLocation);
            if (!Files.exists(downloadDirPath)) {
                Files.createDirectories(downloadDirPath);
                log.info("Created download directory: {}", downloadDirPath);
            }
        } catch (Exception e) {
            log.error("Failed to initialize Azure Blob Storage client or create download directory: {}", e.getMessage(), e);
            // This is a critical startup error. Consider exiting or more robust handling.
            throw new RuntimeException("Failed to initialize FileDownloadService", e);
        }
    }


    /**
     * Downloads a file from Bloomberg's content API.
     * The download URL is constructed based on the Bloomberg API documentation (GET /catalogs/{catalog}/content/responses/{key}).
     * It uses WebClient to stream the file content and DataBufferUtils to write it non-blocking to local storage.
     *
     * @param catalogId The Bloomberg catalog identifier.
     * @param fileKey   The key for the downloadable output file.
     * @param requestId The original request ID for auditing purposes.
     * @return Mono emitting the path to the downloaded file.
     */
    public Mono<Path> downloadFile(String catalogId, String fileKey, String requestId) {
        // First, get the OAuth token
        return oAuthService.getAccessToken()
                .flatMap(accessToken -> {
                    String blobFileName = fileKey + ".std"; // Assuming .std extension for Bloomberg output files
                    Path filePath = Paths.get(downloadLocation, blobFileName);

                    log.info("Attempting to download file '{}' from Bloomberg content API to local path: {}", blobFileName, filePath);
                    auditService.logEvent(requestId, "DOWNLOAD_STARTED", "IN_PROGRESS", "Starting file download for key: " + fileKey, fileKey).subscribe();

                    // Construct the Bloomberg download URL as per image
                    String downloadUrl = String.format("/catalogs/%s/content/responses/%s", catalogId, fileKey);

                    return azureBlobWebClient.get() // Note: Renamed from bloombergDownloadWebClient for clarity in prev version.
                                             // It uses the baseUrl from azure.blob.storage.baseUrl in application.yml,
                                             // which points to Bloomberg's content API as per the images.
                            .uri(downloadUrl)
                            .header(HttpHeaders.AUTHORIZATION, "Bearer " + accessToken)
                            .retrieve()
                            .onStatus(HttpStatus::isError, clientResponse ->
                                    clientResponse.bodyToMono(String.class)
                                            .flatMap(errorBody -> Mono.error(new RuntimeException(
                                                    String.format("File download failed with status %s: %s", clientResponse.statusCode(), errorBody)
                                            )))
                            )
                            .bodyToFlux(DataBuffer.class) // Stream data buffers
                            .doOnNext(dataBuffer -> log.debug("Received data buffer chunk for file key: {}", fileKey))
                            .doOnError(e -> {
                                log.error("Error receiving data buffers for key {}: {}", fileKey, e.getMessage());
                                auditService.logEvent(requestId, "DOWNLOAD_STREAM_FAILED", "FAILURE", "Error during data buffer streaming: " + e.getMessage(), fileKey).subscribe();
                            })
                            .let(dataBufferFlux -> { // Use .let to apply a transformation to the Flux
                                // DataBufferUtils.write returns Mono<Void>
                                return DataBufferUtils.write(dataBufferFlux, filePath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING);
                            })
                            .then(Mono.defer(() -> { // This block executes AFTER the file writing is complete
                                log.info("File '{}' downloaded successfully to: {}", blobFileName, filePath);
                                // Audit successful download
                                return auditService.logEvent(requestId, "DOWNLOAD_COMPLETED", "SUCCESS", "File downloaded successfully.", filePath.toString())
                                        .flatMap(auditLog -> // After auditing, send notification to OASYS
                                            oasysNotificationService.sendDownloadCompletionNotification(fileKey, filePath.toString(), requestId) // Pass requestId for OASYS audit too
                                        )
                                        .thenReturn(filePath); // Return the file path at the end of the entire chain
                            }))
                            .retryWhen(Retry.backoff(3, Duration.ofSeconds(5))
                                    .filter(throwable -> throwable instanceof RuntimeException && throwable.getMessage().contains("status 5"))
                                    .doBeforeRetry(retrySignal -> log.warn("Retrying file download for key {}. Attempt: {}", fileKey, retrySignal.totalRetries() + 1))
                                    .onRetryExhausted((retryBackoffSpec, retrySignal) ->
                                            log.error("Max retries for file download key {} exhausted.", fileKey)
                                    )
                            )
                            .doOnError(e -> {
                                log.error("Final error during file download for key {}: {}", fileKey, e.getMessage());
                                auditService.logEvent(requestId, "DOWNLOAD_FAILED", "FAILURE", "Final download error: " + e.getMessage(), fileKey).subscribe();
                            });
                });
    }
}
```java
// src/main/java/com/bloomberg/psr/notification/OasysNotificationPayload.java
package com.bloomberg.psr.notification;

/**
 * Represents the payload structure for the internal OASYS notification API.
 * Customize this based on your actual OASYS API requirements.
 */
public class OasysNotificationPayload {
    private String downloadKey;
    private String filePath;
    private String status; // e.g., "COMPLETED", "FAILED"
    private String message;
    private String requestId; // To link notification to original PSR request

    public OasysNotificationPayload(String downloadKey, String filePath, String status, String message, String requestId) {
        this.downloadKey = downloadKey;
        this.filePath = filePath;
        this.status = status;
        this.message = message;
        this.requestId = requestId;
    }

    // Getters and Setters
    public String getDownloadKey() {
        return downloadKey;
    }

    public void setDownloadKey(String downloadKey) {
        this.downloadKey = downloadKey;
    }

    public String getFilePath() {
        return filePath;
    }

    public void setFilePath(String filePath) {
        this.filePath = filePath;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public String getRequestId() {
        return requestId;
    }

    public void setRequestId(String requestId) {
        this.requestId = requestId;
    }

    @Override
    public String toString() {
        return "OasysNotificationPayload{" +
               "downloadKey='" + downloadKey + '\'' +
               ", filePath='" + filePath + '\'' +
               ", status='" + status + '\'' +
               ", message='" + message + '\'' +
               ", requestId='" + requestId + '\'' +
               '}';
    }
}
```java
// src/main/java/com/bloomberg/psr/notification/OasysNotificationService.java
package com.bloomberg.psr.notification;

import com.bloomberg.psr.audit.AuditService;
import com.bloomberg.psr.oauth.OAuthService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;
import reactor.util.retry.Retry;

import java.time.Duration;

/**
 * Service for sending notifications to the internal OASYS API.
 */
@Service
public class OasysNotificationService {

    private static final Logger log = LoggerFactory.getLogger(OasysNotificationService.class);
    private final WebClient oasysNotificationWebClient;
    private final OAuthService oAuthService; // If OASYS also needs an OAuth token
    private final AuditService auditService; // Inject AuditService

    @Value("${oasys.notification.api.endpoint:/notification}") // Default OASYS notification endpoint
    private String oasysNotificationEndpoint;

    public OasysNotificationService(
            @Qualifier("oasysNotificationWebClient") WebClient oasysNotificationWebClient,
            OAuthService oAuthService,
            AuditService auditService) { // Inject AuditService
        this.oasysNotificationWebClient = oasysNotificationWebClient;
        this.oAuthService = oAuthService;
        this.auditService = auditService; // Initialize AuditService
    }

    /**
     * Sends a notification to the OASYS API indicating successful file download.
     * Assumes OASYS might also need an OAuth token. If not, remove the OAuthService dependency
     * and the 'flatMap' for token retrieval.
     *
     * @param downloadKey The key of the downloaded file (from Bloomberg notification).
     * @param filePath    The local path where the file was saved.
     * @param requestId   The original request ID to associate with this notification.
     * @return Mono<Void> indicating completion of the notification sending.
     */
    public Mono<Void> sendDownloadCompletionNotification(String downloadKey, String filePath, String requestId) {
        OasysNotificationPayload payload = new OasysNotificationPayload(
                downloadKey,
                filePath,
                "COMPLETED",
                "Bloomberg PSR file download successful.",
                requestId
        );

        // Assuming OASYS API also needs an OAuth token, retrieve it.
        // If not, remove this flatMap and directly call oasysNotificationWebClient.post()
        return oAuthService.getAccessToken() // Assuming OASYS also needs a token, potentially a different one
                .flatMap(oasysAccessToken -> {
                    log.info("Sending download completion notification to OASYS for key: {} (Request ID: {})", downloadKey, requestId);
                    auditService.logEvent(requestId, "OASYS_NOTIFICATION_ATTEMPT", "IN_PROGRESS", "Attempting to send notification to OASYS.", downloadKey).subscribe();

                    return oasysNotificationWebClient.post()
                            .uri(oasysNotificationEndpoint)
                            // .header(HttpHeaders.AUTHORIZATION, "Bearer " + oasysAccessToken) // Uncomment if OASYS requires auth
                            .bodyValue(payload)
                            .retrieve()
                            .onStatus(HttpStatus::isError, clientResponse ->
                                    clientResponse.bodyToMono(String.class)
                                            .flatMap(errorBody -> Mono.error(new RuntimeException(
                                                    String.format("OASYS notification failed with status %s: %s", clientResponse.statusCode(), errorBody)
                                            )))
                            )
                            .toBodilessEntity() // We expect no body in return, just status
                            .retryWhen(Retry.backoff(3, Duration.ofSeconds(2))
                                    .filter(throwable -> throwable instanceof RuntimeException && throwable.getMessage().contains("status 5"))
                                    .doBeforeRetry(retrySignal -> log.warn("Retrying OASYS notification for key {}. Attempt: {}", downloadKey, retrySignal.totalRetries() + 1))
                                    .onRetryExhausted((retryBackoffSpec, retrySignal) ->
                                            log.error("Max retries for OASYS notification key {} exhausted.", downloadKey)
                                    )
                            )
                            .doOnSuccess(response -> {
                                log.info("Successfully sent OASYS notification for key: {} (Request ID: {})", downloadKey, requestId);
                                auditService.logEvent(requestId, "OASYS_NOTIFICATION_SENT", "SUCCESS", "Notification sent to OASYS successfully.", downloadKey).subscribe();
                            })
                            .doOnError(e -> {
                                log.error("Error sending OASYS notification for key {} (Request ID: {}): {}", downloadKey, requestId, e.getMessage());
                                auditService.logEvent(requestId, "OASYS_NOTIFICATION_FAILED", "FAILURE", "Failed to send notification to OASYS: " + e.getMessage(), downloadKey).subscribe();
                            })
                            .then(); // Convert to Mono<Void>
                })
                .doOnError(e -> {
                    log.error("Failed to get OAuth token for OASYS notification for key {} (Request ID: {}): {}", downloadKey, requestId, e.getMessage());
                    auditService.logEvent(requestId, "OASYS_AUTH_FAILED", "FAILURE", "Failed to get OAuth token for OASYS notification: " + e.getMessage(), downloadKey).subscribe();
                });
    }
}
```java
// src/main/java/com/bloomberg/psr/controller/PsrController.java
package com.bloomberg.psr.controller;

import com.bloomberg.psr.audit.AuditService;
import com.bloomberg.psr.request.PsrRequestPayload;
import com.bloomberg.psr.request.PsrRequestService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import reactor.core.publisher.Mono;

import java.util.UUID;

/**
 * REST Controller for handling incoming Bloomberg PSR requests from internal clients.
 * This controller provides an API endpoint that immediately responds and
 * initiates the full Bloomberg PSR workflow (request, polling, download, notification)
 * in the background.
 */
@RestController
@RequestMapping("/api/psr")
public class PsrController {

    private static final Logger log = LoggerFactory.getLogger(PsrController.class);
    private final PsrRequestService psrRequestService;
    private final AuditService auditService; // Inject AuditService

    public PsrController(PsrRequestService psrRequestService, AuditService auditService) {
        this.psrRequestService = psrRequestService;
        this.auditService = auditService;
    }

    /**
     * Accepts a Bloomberg PSR request from a client.
     * It immediately returns an HTTP 202 Accepted response,
     * and then asynchronously initiates the Bloomberg request, SSE polling,
     * file download, and OASYS notification process in the background.
     *
     * @param payload The Bloomberg PSR request payload.
     * @return Mono emitting a ResponseEntity with immediate status and a message.
     */
    @PostMapping("/request")
    public Mono<ResponseEntity<String>> submitPsrRequest(@RequestBody PsrRequestPayload payload) {
        // Generate a unique requestId if not provided, or ensure it's unique
        if (payload.getRequestId() == null || payload.getRequestId().isEmpty()) {
            payload.setRequestId(UUID.randomUUID().toString());
        }
        final String requestId = payload.getRequestId(); // Use final variable in lambda

        log.info("Received PSR request for ID: {}. Initiating background processing.", requestId);

        // Audit the reception of the request from the local API
        auditService.logEvent(requestId, "API_REQUEST_RECEIVED", "ACCEPTED", "PSR request received from client via local API.", requestId).subscribe();


        // In the background, submit the PSR request to Bloomberg
        // We subscribe to the Mono without blocking, allowing the HTTP response to be sent immediately.
        psrRequestService.submitPsrRequest(payload)
                .doOnSubscribe(subscription -> {
                    log.debug("Subscribing to Bloomberg PSR request (background) for ID: {}", requestId);
                    auditService.logEvent(requestId, "BACKGROUND_PROCESSING_INITIATED", "IN_PROGRESS", "Background processing for Bloomberg PSR request started.", requestId).subscribe();
                })
                .doOnError(e -> {
                    log.error("Background processing failed for PSR request ID {}: {}", requestId, e.getMessage(), e);
                    // Log a final audit for the background process failure
                    auditService.logEvent(requestId, "BACKGROUND_PROCESSING_FAILED", "FAILURE", "Background processing for PSR failed: " + e.getMessage(), requestId).subscribe();
                })
                .subscribe(); // Crucial: subscribe to trigger the reactive flow in the background

        // Immediately return a response to the client
        return Mono.just(
                ResponseEntity.accepted().body("PSR request with ID " + requestId + " accepted for background processing.")
        );
    }
}
```java
// src/main/java/com/bloomberg/psr/util/GlobalExceptionHandler.java
package com.bloomberg.psr.util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.support.WebExchangeBindException;
import org.springframework.web.server.ResponseStatusException;

/**
 * Global exception handler for the Spring Boot application.
 * Provides a centralized way to handle exceptions and return meaningful error responses.
 */
@ControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    /**
     * Handles generic RuntimeExceptions.
     *
     * @param ex The RuntimeException that occurred.
     * @return A ResponseEntity with an appropriate HTTP status and error message.
     */
    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<String> handleRuntimeException(RuntimeException ex) {
        log.error("Runtime exception caught: {}", ex.getMessage(), ex);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("An unexpected error occurred: " + ex.getMessage());
    }

    /**
     * Handles specific WebExchangeBindException (e.g., validation errors in reactive endpoints).
     *
     * @param ex The WebExchangeBindException that occurred.
     * @return A ResponseEntity with HTTP 400 Bad Request status and validation error details.
     */
    @ExceptionHandler(WebExchangeBindException.class)
    public ResponseEntity<String> handleWebExchangeBindException(WebExchangeBindException ex) {
        log.error("Validation error: {}", ex.getMessage());
        String errorMessage = ex.getBindingResult().getAllErrors().stream()
                .map(error -> error.getDefaultMessage())
                .findFirst()
                .orElse("Validation failed.");
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                .body("Invalid request payload: " + errorMessage);
    }

    /**
     * Handles ResponseStatusException (e.g., from WebClient when an error status is returned).
     *
     * @param ex The ResponseStatusException that occurred.
     * @return A ResponseEntity with the status and reason from the exception.
     */
    @ExceptionHandler(ResponseStatusException.class)
    public ResponseEntity<String> handleResponseStatusException(ResponseStatusException ex) {
        log.error("Response status exception: {} - {}", ex.getStatus(), ex.getReason());
        return ResponseEntity.status(ex.getStatus())
                .body(ex.getReason());
    }

    // Add more specific exception handlers as needed, e.g., for IOException, TimeoutException
}
```yaml
# src/main/resources/application.yml
server:
  port: 8080

# Bloomberg API Configuration
bloomberg:
  oauth:
    tokenUrl: https://api.bloomberg.com/oauth/token # Placeholder, replace with actual Bloomberg OAuth token URL
    clientId: your-bloomberg-client-id # Replace with your actual Bloomberg Client ID
    clientSecret: your-bloomberg-client-secret # Replace with your actual Bloomberg Client Secret
    grantType: client_credentials # Or 'authorization_code' depending on your OAuth flow
  psr:
    api:
      baseUrl: https://api.bloomberg.com/dl/rest/api/ # Placeholder, replace with actual Bloomberg DL REST API base URL
      catalog: 1234 # Replace with your Bloomberg Catalog ID (e.g., your DL account number)
  sse:
    baseUrl: https://api.bloomberg.com/dl/rest/api/ # Placeholder, replace with actual Bloomberg SSE API base URL
    api-path: /notifications/sse # SSE endpoint path

# Azure Blob Storage Configuration (Base URL points to Bloomberg's content API as per image)
azure:
  blob:
    storage:
      # This connection string typically includes account name and key.
      # Example: "DefaultEndpointsProtocol=https;AccountName=youraccount;AccountKey=yourkey;EndpointSuffix=core.windows.net"
      connectionString: DefaultEndpointsProtocol=https;AccountName=youraccountname;AccountKey=youraccountkey;EndpointSuffix=core.windows.net # Replace with your Azure Storage Connection String
      containerName: bloomberg-psr-downloads # Replace with your Azure Blob Storage container name
    baseUrl: https://api.bloomberg.com/dl/rest/api/ # Points to Bloomberg's download endpoint as suggested by images

# Internal OASYS Notification API Configuration
oasys:
  notification:
    api:
      baseUrl: http://localhost:8081 # Placeholder, replace with your internal OASYS API base URL
      endpoint: /notification # Endpoint path for sending notifications

# Application specific configurations
app:
  download:
    location: ./downloads # Local directory where downloaded files will be stored. Creates if not exists.

# PostgreSQL R2DBC Configuration for Audit Logging
spring:
  r2dbc:
    url: r2dbc:postgresql://localhost:5432/your_database_name # Replace with your PostgreSQL URL and database name
    username: your_username # Replace with your PostgreSQL username
    password: your_password # Replace with your PostgreSQL password
  # Enable R2DBC schema initialization (optional, can be done manually or with Flyway/Liquibase)
  # r2dbc.initialization-mode: always
  # r2dbc.schema: classpath:db/schema.sql # Points to the SQL file for schema creation

logging:
  level:
    com.bloomberg.psr: DEBUG # Set log level for your application packages
    reactor.netty: INFO
    org.springframework.web.reactive.function.client: DEBUG # To see WebClient request/response details
    org.springframework.data.r2dbc: DEBUG # To see R2DBC related logs
```xml
<!-- src/main/resources/pom.xml -->
<!-- Add these dependencies to your existing pom.xml -->

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-r2dbc</artifactId>
</dependency>
<dependency>
    <groupId>io.r2dbc</groupId>
    <artifactId>r2dbc-postgresql</artifactId>
    <scope>runtime</scope>
</dependency>
<!-- For ObjectMapper in AppConfig and SSE parsing -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
</dependency>
<!-- Azure Blob Storage SDK -->
<dependency>
    <groupId>com.azure</groupId>
    <artifactId>azure-storage-blob</artifactId>
    <version>12.26.0</version> <!-- Use a recent stable version -->
</dependency>
```sql
-- src/main/resources/db/schema.sql
-- SQL to create the audit_log table for PostgreSQL
CREATE TABLE IF NOT EXISTS audit_log (
    id BIGSERIAL PRIMARY KEY,
    request_id VARCHAR(255) NOT NULL,
    event_type VARCHAR(100) NOT NULL,
    status VARCHAR(50) NOT NULL,
    message TEXT,
    related_key VARCHAR(255),
    timestamp TIMESTAMP NOT NULL DEFAULT NOW()
);
