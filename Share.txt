import reactor.core.publisher.Mono;
import reactor.core.publisher.Flux;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.ClientResponse;
import java.time.Duration;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

public class ParallelFetcher {
    private final WebClient webClient;
    private final AtomicReference<Mono<Void>> authRefreshMono = new AtomicReference<>(Mono.empty());

    public ParallelFetcher(WebClient webClient) {
        this.webClient = webClient;
    }

    public List<String> fetchDataInParallel(List<String> urls) {
        return Flux.fromIterable(urls)
                .flatMap(this::fetchData, 10) // Limit concurrency
                .collectList()
                .block();
    }

    private Mono<String> fetchData(String url) {
        return makeRequest(url)
                .flatMap(response -> {
                    if (response.statusCode().is2xxSuccessful()) {
                        return response.bodyToMono(String.class);
                    } else if (isAuthError(response)) {
                        return retryAfterAuthRefresh(url);
                    } else {
                        return Mono.just("Error fetching: " + url + " - " + response.statusCode());
                    }
                })
                .timeout(Duration.ofSeconds(15))
                .onErrorResume(e -> Mono.just("Error fetching: " + url));
    }

    private Mono<ClientResponse> makeRequest(String url) {
        return webClient.get()
                .uri(url)
                .retrieve()
                .toBodilessEntity()
                .flatMap(response -> Mono.just(ClientResponse.create(response.getStatusCode()).build()));
    }

    private boolean isAuthError(ClientResponse response) {
        int status = response.statusCode().value();
        return status == 401 || status == 403;
    }

    private Mono<String> retryAfterAuthRefresh(String url) {
        return getOrTriggerAuthRefresh()
                .then(makeRequest(url))
                .flatMap(response -> response.bodyToMono(String.class));
    }

    private Mono<Void> getOrTriggerAuthRefresh() {
        return authRefreshMono.updateAndGet(existingMono -> {
            if (existingMono == Mono.empty()) {
                return refreshAuthCookies().cache(); // Cache ensures all waiting requests use the same Mono
            }
            return existingMono;
        });
    }

    private Mono<Void> refreshAuthCookies() {
        return Mono.fromRunnable(() -> {
            System.out.println("Refreshing authentication cookies...");
            // Actual logic to refresh cookies
        })
        .then()
        .doFinally(signal -> authRefreshMono.set(Mono.empty())); // Reset after refresh
    }
}
