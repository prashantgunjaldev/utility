package com.example.proxy;

import io.netty.handler.ssl.SslContextBuilder;
import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.http.client.reactive.ReactorClientHttpConnector;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.reactive.function.client.*;
import reactor.core.publisher.Mono;
import reactor.netty.http.client.HttpClient;

import javax.annotation.PostConstruct;
import java.time.Duration;

@RestController
@RequestMapping("/proxy")
@Slf4j
public class BlobProxyController {

    private WebClient webClient;

    @PostConstruct
    public void init() {
        HttpClient httpClient = HttpClient.create()
            .followRedirect(true)
            .secure(spec -> spec.sslContext(
                SslContextBuilder.forClient()
                    .trustManager(InsecureTrustManagerFactory.INSTANCE)
            ))
            .responseTimeout(Duration.ofSeconds(60));

        this.webClient = WebClient.builder()
            .clientConnector(new ReactorClientHttpConnector(httpClient))
            .defaultHeader(HttpHeaders.USER_AGENT, "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 Chrome/112 Safari/537.36")
            .defaultHeader(HttpHeaders.ACCEPT, "*/*")
            .defaultHeader(HttpHeaders.CONNECTION, "keep-alive")
            .defaultHeader(HttpHeaders.ACCEPT_ENCODING, "gzip, deflate, br")
            .filter(logRequest())
            .filter(logResponse())
            .build();
    }

    @GetMapping("/download")
    public Mono<ResponseEntity<byte[]>> proxyDownload(@RequestParam("sasUrl") String sasUrl) {
        log.info("Proxy download triggered for SAS URL: {}", sasUrl);

        return webClient.get()
            .uri(sasUrl)
            .accept(MediaType.APPLICATION_OCTET_STREAM)
            .retrieve()
            .onStatus(status -> !status.is2xxSuccessful(), response -> {
                log.error("Error from Blob Storage, Status Code: {}", response.statusCode());
                return response.bodyToMono(String.class).flatMap(errorBody -> {
                    log.error("Error Body: {}", errorBody);
                    return Mono.error(new RuntimeException("Failed to download from blob: " + response.statusCode()));
                });
            })
            .toEntity(byte[].class)
            .doOnSuccess(entity -> {
                log.info("Blob file download successful, size: {} bytes", (entity.getBody() != null ? entity.getBody().length : 0));
            })
            .doOnError(error -> {
                log.error("Exception during download", error);
            });
    }

    private ExchangeFilterFunction logRequest() {
        return ExchangeFilterFunction.ofRequestProcessor(clientRequest -> {
            log.info("Request: {} {}", clientRequest.method(), clientRequest.url());
            clientRequest.headers().forEach((name, values) -> values.forEach(value -> log.info("{}={}", name, value)));
            return Mono.just(clientRequest);
        });
    }

    private ExchangeFilterFunction logResponse() {
        return ExchangeFilterFunction.ofResponseProcessor(clientResponse -> {
            log.info("Response Status: {}", clientResponse.statusCode());
            clientResponse.headers().asHttpHeaders()
                .forEach((name, values) -> values.forEach(value -> log.info("{}={}", name, value)));
            return Mono.just(clientResponse);
        });
    }
}
