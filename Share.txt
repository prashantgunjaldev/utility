import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.Map;
import java.util.concurrent.*;
import java.util.stream.Collectors;

public class MultiThreadedFileDownloader {

    private static final int MAX_THREADS = 500; // Adjustable

    // Environment specific URLs
    private static final String DEV_DOWNLOAD_URL = "https://dev.example.com/download";
    private static final String TEST_DOWNLOAD_URL = "https://test.example.com/download";
    private static final String DEV_AUTH_URL = "https://dev.example.com/auth";
    private static final String TEST_AUTH_URL = "https://test.example.com/auth";

    public static void main(String[] args) throws Exception {
        String csvFile = null, downloadDir = null, env = "dev";
        boolean downloadEnabled = true;

        for (String arg : args) {
            if (arg.startsWith("csvFile=")) csvFile = arg.split("=", 2)[1];
            else if (arg.startsWith("downloadDir=")) downloadDir = arg.split("=", 2)[1];
            else if (arg.startsWith("env=")) env = arg.split("=", 2)[1];
            else if (arg.startsWith("downloadEnabled=")) downloadEnabled = Boolean.parseBoolean(arg.split("=", 2)[1]);
        }

        if (csvFile == null) {
            System.out.println("Usage: java MultiThreadedFileDownloader csvFile=<CSV_FILE_PATH> [downloadDir=<DOWNLOAD_DIR>] [env=dev/test] [downloadEnabled=true/false]");
            return;
        }

        String downloadUrl = env.equalsIgnoreCase("test") ? TEST_DOWNLOAD_URL : DEV_DOWNLOAD_URL;
        String authUrl = env.equalsIgnoreCase("test") ? TEST_AUTH_URL : DEV_AUTH_URL;

        String authToken = fetchAuthToken(authUrl);
        List<Map<String, String>> params = parseCsv(csvFile);
        if (downloadEnabled) Files.createDirectories(Path.of(downloadDir));

        int availableProcessors = Runtime.getRuntime().availableProcessors();
        int optimalThreads = Math.min(MAX_THREADS, availableProcessors * 2);

        ExecutorService executor = Executors.newFixedThreadPool(optimalThreads);

        for (Map<String, String> param : params) {
            executor.submit(() -> generateSasOrDownload(downloadUrl, param, authToken, downloadDir, downloadEnabled));
        }

        executor.shutdown();
        executor.awaitTermination(1, TimeUnit.HOURS);
        System.out.println("All tasks completed.");
    }

    private static String fetchAuthToken(String authUrl) throws IOException {
        URL url = new URL(authUrl);
        HttpURLConnection conn = (HttpURLConnection) url.openConnection();
        conn.setRequestMethod("GET");

        try (BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {
            String response = reader.lines().collect(Collectors.joining());
            return response.split("\"")[3];
        }
    }

    private static void generateSasOrDownload(String urlString, Map<String, String> params, String authToken, String downloadDir, boolean downloadEnabled) {
        try {
            long start = System.currentTimeMillis();
            URL url = new URL(urlString);
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();
            conn.setInstanceFollowRedirects(false);
            conn.setRequestMethod("POST");
            conn.setRequestProperty("Authorization", "Bearer " + authToken);
            conn.setDoOutput(true);

            try (OutputStream os = conn.getOutputStream()) {
                String postData = "filename=" + params.get("filename") + "&businessDate=" + params.get("businessDate") + "&vendor=" + params.get("vendor");
                os.write(postData.getBytes());
            }

            if (conn.getResponseCode() == 303) {
                String redirectUrl = conn.getHeaderField("Location");
                long duration = System.currentTimeMillis() - start;
                System.out.println("SAS URL Generated: " + redirectUrl + " in " + duration + " ms");
                Files.writeString(Path.of(downloadDir, "sas_stats.txt"), "SAS URL: " + redirectUrl + " in " + duration + " ms\n", StandardOpenOption.CREATE, StandardOpenOption.APPEND);

                if (downloadEnabled) downloadFile(redirectUrl, downloadDir, params.get("filename"));
            }
        } catch (Exception e) {
            System.err.println("Failed to generate SAS URL for " + params.get("filename"));
        }
    }

    private static void downloadFile(String fileUrl, String downloadDir, String filename) throws IOException {
        long start = System.currentTimeMillis();
        URL url = new URL(fileUrl);
        String timestampedName = filename + "_" + System.currentTimeMillis();
        Path destination = Path.of(downloadDir, timestampedName);

        try (InputStream in = url.openStream()) {
            Files.copy(in, destination, StandardCopyOption.REPLACE_EXISTING);
            long duration = System.currentTimeMillis() - start;
            System.out.println("Downloaded: " + destination + " in " + duration + " ms");
            Files.writeString(Path.of(downloadDir, "download_stats.txt"), "Downloaded: " + destination.getFileName() + " in " + duration + " ms\n", StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        }
    }

    private static List<Map<String, String>> parseCsv(String csvFile) throws IOException {
        return Files.readAllLines(Path.of(csvFile)).stream().skip(1).map(line -> {
            String[] parts = line.split(",");
            return Map.of(
                    "filename", parts[0],
                    "businessDate", parts[1],
                    "vendor", parts[2]
            );
        }).collect(Collectors.toList());
    }
}
