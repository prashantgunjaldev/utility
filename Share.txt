 return CompletableFuture.supplyAsync(() -> fetchData(input.getEndpoint()), executorService)
                .thenApply(this::processResult)
                .join(); // Blocking here, but allows parallel execution

@Override
public YourOutputType process(YourInputType input) {
    List<CompletableFuture<YourOutputType>> futures = input.getUrls().stream()
        .map(url -> CompletableFuture.supplyAsync(() -> 
            webClient.get()
                .uri(url)
                .retrieve()
                .bodyToMono(YourOutputType.class)
                .block()
        , taskExecutor))  // âœ… Runs in parallel thread pool
        .collect(Collectors.toList());

    // Wait for all requests to complete
    return futures.stream()
        .map(CompletableFuture::join)  // âœ… Gather all results
        .findFirst()  // Example: Pick first result
        .orElse(null);
}

public WebClient webClient() {
        // Create a Connection Pool Provider with high concurrency settings
        ConnectionProvider provider = ConnectionProvider.builder("custom-webclient-pool")
            .maxConnections(100) // ðŸš€ Increase max connections (default is 5)
            .pendingAcquireMaxCount(1000) // ðŸš€ Allow 1000 waiting requests
            .pendingAcquireTimeout(Duration.ofSeconds(5)) // Timeout for pending requests
            .build();

        HttpClient httpClient = HttpClient.create(provider)
            .responseTimeout(Duration.ofSeconds(10)) // ðŸš€ Set response timeout
            .doOnConnected(conn ->
                conn.addHandlerLast(new io.netty.handler.timeout.ReadTimeoutHandler(10))
                    .addHandlerLast(new io.netty.handler.timeout.WriteTimeoutHandler(10))
            );

        return WebClient.builder()
            .clientConnector(new ReactorClientHttpConnector(httpClient))
            .build();
    }
