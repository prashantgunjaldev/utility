import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.WebClientResponseException;
import reactor.util.retry.Retry;

import java.time.Duration;
import java.util.List;

public class MorningstarLoginWorker {

    public static List<String> getCookies(WebClient webClient, String endpoint, String username, String password) {
        HttpHeaders headers = new HttpHeaders();
        headers.setBasicAuth(username, password);
        headers.setContentType(MediaType.APPLICATION_JSON);

        try {
            return webClient.get()
                .uri(endpoint)
                .headers(httpHeaders -> httpHeaders.addAll(headers))
                .retrieve()
                .toBodilessEntity()
                .map(response -> response.getHeaders().get(HttpHeaders.SET_COOKIE))
                .retryWhen(Retry.fixedDelay(1, Duration.ofSeconds(2))) // Retry once after 2 seconds
                .block();
        } catch (WebClientResponseException e) {
            System.err.println("Failed to connect to MorningStar Server, Error: " + e.getMessage());
        }
        return null;
    }
}


===========

import reactor.core.publisher.Mono;
import reactor.core.publisher.Flux;
import org.springframework.web.reactive.function.client.WebClient;
import org.springframework.web.reactive.function.client.ClientResponse;
import java.time.Duration;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;

public class ParallelFetcher {
    private final WebClient webClient;
    private final AtomicBoolean authRefreshed = new AtomicBoolean(false);

    public ParallelFetcher(WebClient webClient) {
        this.webClient = webClient;
    }

    public List<String> fetchDataInParallel(List<String> urls) {
        return Flux.fromIterable(urls)
                .flatMap(this::fetchData, 10) // Parallel execution
                .collectList()
                .block(); // Blocking call to return List
    }

    private Mono<String> fetchData(String url) {
        return makeRequest(url)
                .flatMap(response -> {
                    if (response.statusCode().is2xxSuccessful()) {
                        return response.bodyToMono(String.class);
                    } else if (isAuthError(response)) {
                        return handleAuthError(url);
                    } else {
                        return Mono.just("Error fetching: " + url + " - " + response.statusCode());
                    }
                })
                .timeout(Duration.ofSeconds(15))
                .onErrorResume(e -> Mono.just("Error fetching: " + url));
    }

    private Mono<ClientResponse> makeRequest(String url) {
        return webClient.get()
                .uri(url)
                .retrieve()
                .toBodilessEntity()
                .flatMap(response -> Mono.just(ClientResponse.create(response.getStatusCode()).build()));
    }

    private boolean isAuthError(ClientResponse response) {
        return response.statusCode().value() == 401 || response.statusCode().value() == 403;
    }

    private Mono<String> handleAuthError(String url) {
        if (authRefreshed.compareAndSet(false, true)) {
            return refreshAuthCookies()
                    .then(makeRequest(url))
                    .flatMap(response -> response.bodyToMono(String.class))
                    .doFinally(signalType -> authRefreshed.set(false));
        } else {
            return Mono.just("Authentication error fetching: " + url);
        }
    }

    private Mono<Void> refreshAuthCookies() {
        return Mono.fromRunnable(() -> {
            System.out.println("Refreshing authentication cookies...");
            // Your logic to refresh cookies
        }).then();
    }
}
