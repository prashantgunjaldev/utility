import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import java.io.IOException;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
class RequestResponseLoggingFilterTest {

    @Mock
    private LoggingService mockLoggingService;

    @Mock
    private HttpServletRequest mockRequest;

    @Mock
    private HttpServletResponse mockResponse;

    @Mock
    private FilterChain mockFilterChain;

    private RequestResponseLoggingFilter filter;

    @BeforeEach
    void setUp() {
        // Create the filter with DB logging enabled by default
        filter = new RequestResponseLoggingFilter(mockLoggingService, true);
    }

    @Test
    void testDoFilterInternal_LoggingEnabled() throws ServletException, IOException {
        // Arrange: set up request stubs
        when(mockRequest.getMethod()).thenReturn(\"GET\");
        when(mockRequest.getRequestURI()).thenReturn(\"/test\");
        when(mockRequest.getRemoteAddr()).thenReturn(\"127.0.0.1\");
        when(mockRequest.getHeader(\"User-Agent\")).thenReturn(\"MockUserAgent\");

        // Act
        filter.doFilterInternal(mockRequest, mockResponse, mockFilterChain);

        // Assert: verify LoggingService is called
        verify(mockLoggingService, times(1)).log(any());
        verify(mockFilterChain, times(1)).doFilter(mockRequest, mockResponse);
    }

    @Test
    void testDoFilterInternal_LoggingDisabled() throws ServletException, IOException {
        // Re-initialize the filter with logging disabled
        filter = new RequestResponseLoggingFilter(mockLoggingService, false);

        // Act
        filter.doFilterInternal(mockRequest, mockResponse, mockFilterChain);

        // Assert: logging should NOT occur
        verify(mockLoggingService, never()).log(any());
        // The filter chain should still proceed
        verify(mockFilterChain, times(1)).doFilter(mockRequest, mockResponse);
    }

    @Test
    void testDoFilterInternal_CapturesApiLogFields() throws ServletException, IOException {
        // Optionally, you can capture the ApiLog passed to LoggingService and assert fields
        when(mockRequest.getMethod()).thenReturn(\"POST\");
        when(mockRequest.getRequestURI()).thenReturn(\"/my-api\");
        when(mockRequest.getRemoteAddr()).thenReturn(\"192.168.1.100\");
        when(mockRequest.getHeader(\"User-Agent\")).thenReturn(\"MyTestAgent\");

        filter.doFilterInternal(mockRequest, mockResponse, mockFilterChain);

        // Capture the ApiLog argument
        ArgumentCaptor<ApiLog> logCaptor = ArgumentCaptor.forClass(ApiLog.class);
        verify(mockLoggingService).log(logCaptor.capture());
        ApiLog capturedLog = logCaptor.getValue();

        // Now assert fields
        assertEquals(\"POST\", capturedLog.getMethod());
        assertEquals(\"/my-api\", capturedLog.getUri());
        assertEquals(\"192.168.1.100\", capturedLog.getIp());
        // etc.

        verify(mockFilterChain).doFilter(mockRequest, mockResponse);
    }
}
